### 그래프와 트리의 차이
#### 그래프
- 그래프는 정점과 간선으로 이루어진 구조입니다.
- 정점 (Vertex) : 그래프의 노드, 데이터를 나타냅니다.
- 간선 (Edge) : 정점 간의 연결, 관계나 경로를 나타냅니다.
- 가중치 (Weight) : 간선에 부여된 값으로 거리, 비용, 시간 등을 나타냅니다.
- 그래프는 방향성 여부에 따라 방향 그래프와 무방향 그래프로 나눌 수 있습니다.
- 네트워크를 설계하거나 작업의 우선순위를 결정할 때 효율적 입니다.
#### 트리
- 트리는 정점과 간선으로 계층형 구조를 표현하는 구조입니다.
- 정점 (Vertex) : 트리의 각 노드
- 간선 (Edge) : 두 노드를 연결하는 선
- 루트 (Root) : 트리의 최상단에 있는 노드
- 트리는 구조에 따라 이진 트리, 이진 탐색 트리, 균형 이진 트리 등이 있습니다.
> 트리와 그래프 모두 정점과 간선으로 이루어진 구조입니다. 그래프는 네트워크 구조에 가깝고, 트리는 계층적 구조에 가깝다는 것이 큰 차이점입이다. 때문에 그래프는 사이클을 가질 수 있고 루트 노드가 없지만 트리는 사이클을 가질 수 없고 루트 노드가
> 항상 존재합니다. 또 계층형 구조이기 때문에 트리는 단일 경로로 연결되어 있지만 그래프는 정점 간 여러가지의 경로를 가질 수 있습니다.

## 쿠키와 세션의 차이
#### 쿠키
- HTTP의 일종으로 해당 사이트가 사용하고 있는 서버에서 사용자의 컴퓨터에 데이터를 저장하는 작은 기록 정보입니다.
- HTTP에서 클라이언트의 상태 정보를 쿠키 형태로 클라이언트 PC에 저장하였다가 필요 시 정보를 참조하거나 재사용할 수 있습니다.
- Key - Value 쌍으로 구성되어 있습니다.
- 세션관리, 개인화, 트래킹의 목적으로 사용됩니다.
#### 세션
- 일정 시간동안 같은 사용자로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 유지시키는 기술입니다.
- 방문자가 웹 브라우저를 종료하기전까지 세션을 유지합니다.
- 웹 서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장합니다.
- 브라우저를 닫거나 서버에서 세션을 삭제 했을 때만 삭제가 되기 떄문에 쿠키보다 비교적 보안적으로 우수합니다.
- 저장 데이터에 제한이 없습니다.
- 보안적으로 중요한 정보를 다루기 위해 사용합니다.
- 세션 내용은 서버에 저장되기 떄문에 계속하여 늘어날 경우 서버에 부하가 발생할 수 있으며, 쿠키에 비해 비교적 속도가 느립니다.
> 쿠키는 클라이언트에 저장되며 사이트가 사용하고 이는 서버에서 사용자의 컴퓨터에 데이터를 저장하는 기록 정보입니다. 쿠키에 정보가 있어 속도가 비교적 빠르고 세션 관리, 개인화, 트래킹등을 목적으로 사용됩니다. 세션은 일정 시간동안 사용자의 정보를 유지시키는 것으로 서버에 저장는 구조입니다. 보안적으로 중요한 정보를 다룰 때 사용하고, 보안적으로 우수하나 쿠키보단 느린 속도를 가집니다.

## 정규화란?
#### 정규화

정규화는 데이터 베이스 설계 과정에서 데이터의 중복을 최소화하고, 데이터 무결성과 효율성을 유지하기 위해 데이터를 논리적으로 구조화하는 방법입니다. 
- 데이터 중복 제거, 무결성 유지, 갱신 이상 방지의 목적을 가지고 있습니다.
- 아래의 단계대로 구성되어 있습니다.
  - 제 1 정규형 : 데이터가 원자값만을 포함하도록 테이블을 설계
  - 제 2 정규형 : 1정규형 만족 + 부분함수 종속 제거
  - 제 3 정규형 : 제 2 정규형을 만족하고, 이행적 함수 종속성을 제거
  - 보이스-코드 정규형 : 제 3 정규형을 만족하면서 모든 결정자가 후보키여야함
  - 제 4 정규형 : 다치 종속성을 제거하여 데이터 중복을 더 줄인다.
  - 제 5 정규형 : 조인 종속성을 제거하여 데이터 중복을 완전히 없앤다.
- 지나치게 정규화를 하면 테이블이 많아져 조인이 복잡할 수 있습니다. 이는 곧 성능 저하를 일으킬 수 있기에 역정규화도 고려해야합니다.
> 정규화는 데이터 무결성 유지와 중복 제거를 위해 데이터를 논리적으로 구조화하는 방법입니다. 총 6단계의 정규화 과정이 존재하고, 각 단계는 하위 단계를 만족한 상태에서 진행됩니다. 정규화를 통해 무결성 유지와 효율성을 높일 수 있지만 정규화가 지나치면 테이블이 많아져 조인 성능에 악영향을 미칠 수 있습니다.

## DFS와 BFS의 차이
## DFS (Depth-Frist-Search)
- 트리나 그래프를 탐색하는 기법 중 하나로 시작 노드에서 자식의 노드들은 순서대로 탐색하면서 깊이를 우선으로 탐색하는 알고리즘 입니다.
- 깊이를 우선 시하여 모든 경우의 수를 탐색합니다.
- 탐색 과정
  - 현재 노드를 방문한 것으로 표시한다.
  - 방문한 표시가 되어 있지 않는 각각의 인접한 정점을 탐색한다.
  - 더 이상 방문하지 않은 정점이 없으면 이전 정점으로 역추저거한다.
  - 모든 정점을 방문할 때까지 프로세스를 반복한다.
- 장점 : BFS에 비해 메모리 공간을 덜 차지한다. 특정 정점 (또는 모든 정점)에 최대한 빨리 도달하는 것 일때 유용히디.
## BFS (Breadth - First - Search)
- 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회방법입니다.
- 큐를 사용하며 재귀적으로 동작하지 않습니다.
- 탐색 과정
  - 깊이가 적은 노드부터 방문하고 그 다음 깊이의 노드를 방문합니다.
  - 더 이상 방문할 곳이 없는 경우 탐색을 종료합니다.
 
  > DFS는 깊이를 우선으로 BFS는 넓이를 우선으로 탐색하는 알고리즘입니다. DFS는 방문한 표시가 되어 있지 않은 인접 노드들 부터 탐색하여, 가능한 깊이까지 탐색한 후 더이상 방문할 노드가 없을 경우 이전 단계로 되돌아 가는 방식으로 동작합니다. 최단 경로를 보장하지 않으며 경로 탐색이나 미로 문제들에 적합합니다. BFS는 시작 노드에서 가장 가까운 방문하지 않은 노드들 부터 탐색하여, 동일한 깊이를 모두 탐색 후 다음 깊이를 탐색하는 방식으로 동작합니다. 항상 최단 경로를 보장하고 계층적 데이터 처리나 최단 경로 문제에 적합합니다.
