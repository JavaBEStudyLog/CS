## OOP란?

<span style="font-size:16px"> 객체 지향 프로그램 Object Oriented Programming </span>
: 컴퓨터 프로그래밍 패러다임 중 하나로, 여러 개의 독립된 단위인 객체들간의 상호작용을 통해서 프로그램을 만드는 방식  
 인간중심적 프로그래밍으로도 볼 수 있음
현실 세계의 사물들을 객체라고 보고 그 객체로부터 개발하고자 하는 특징들을 뽑아와 프로그래밍하는 것이 특징

#### 장점

- 다른 클래스를 가져와 사용할 수 있고, 상속받을 수 있어 코드 재사용성이 증가
- 자주 사용되는 로직을 라이브러리로 만들어두면 계속해서 사용할 수 있어 신뢰성 확보 가능
- 클래스 단위로 모듈화가 가능하여 대형 프로젝트에 적합
- 객체 단위로 코드가 나눠져 작성되기 때문에 디버깅이 쉽고 유지보수가 용이

#### 단점

- 처리 속도가 상대적으로 느림
- 객체가 많으면 용량이 커짐
- 설계 시 많은 노력과 시간이 필요

#### 객체지향 프로그램의 특성

- **캡슐화** : 연관된 목적을 가지는 변수와 함수를 하나의 클래스로 묶어 외부에서 쉽게 접근하지 못하도록 함  
  &nbsp;&nbsp;&nbsp;&nbsp; => 클래스라는 캡슐에 기능과 특성을 담아 묶음  
  &nbsp;&nbsp;&nbsp;&nbsp; => 변수를 private로 선언하여 데이터를 보호, 보호된 변수는 getter / setter 등 메서드를 통해서만 간접적으로 접근 가능
- **상속** : 기존 상위 클래스를 재사용하는 것으로 상위 클래스의 변수와 메소드를 물려받아 사용할 수 있고, 새로운 기능 추가도 가능
- **추상화** : 객체의 공통적인 속성과 기능을 추출하여 정의하는 것  
  &nbsp;&nbsp;&nbsp;&nbsp; => 중요한 정보면 표현함으로써 공통의 속성과 기능을 묶어 이름을 붙임
- **다형성** : 부모-자식 상속 관계에 있는 클래스에서 한 객체가 상속을 통해 기능을 확장하거나 변경하여 다른 여러 형태로 재구성되는 것  
  &nbsp;&nbsp;&nbsp;&nbsp; => 오버로딩 / 오버라이딩이 대표적임

> **_오버로딩과 오버라이딩_**  
> 오버로딩 : 하나의 클래스 안에서 같은 이름의 메서드를 사용하지만, 각 메서드마다 다른 용도로 사용되면 그 결과물도 다르게 구현되는 것  
> &nbsp;&nbsp;&nbsp;&nbsp; => 메서드끼리 이름이 같지만 매개변수의 개수나 데이터 타입을 다르게 구현  
> 오버라이딩 : 하위 클래스가 상위 클래스에서 만들어진 메서드를 재창조해서 사용하는 것

#### +) 객체지향 설계 원칙 5가지 (SOLID)

- 단일 책임 원칙 Single responsibility principle  
  &nbsp;&nbsp;&nbsp;&nbsp; : 한 클래스는 하나의 책임만 가지며, 클래스는 그 책임을 완전히 캡슐화해야 함
- 개방-폐쇄 원칙 Open / closed principle  
  &nbsp;&nbsp;&nbsp;&nbsp; : 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 변경에 대해서는 닫혀 있어야 함
- 리스코프 치환 원칙 Liskov substitution principle  
  &nbsp;&nbsp;&nbsp;&nbsp; : 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 함
- 인터페이스 분리 원칙 Interface segregation principle  
  &nbsp;&nbsp;&nbsp;&nbsp; : 클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 함  
  &nbsp;&nbsp;&nbsp;&nbsp; : 큰 덩어리의 인터페이스를 구체적이고 작은 단위로 분리함으로써 클라이언트들이 꼭 필요한 메서드만 이용할 수 있게 함
- 의존관계 역전 원칙 Dependency inversion principle  
  &nbsp;&nbsp;&nbsp;&nbsp; : 상의 모듈은 하위 모듈에 의존해서는 안 됨 -> 상위 모듈과 하위 모듈 모두 추상화에 의존해야 함  
  &nbsp;&nbsp;&nbsp;&nbsp; : 추상화는 세부 사항에 의존해서는 안 됨 -> 세부 사항이 추상화에 의존해야 함

---

## 절차 지향 프로그래밍과 객체 지향 프로그래밍의 차이

<span style="background-color:#fff5b1; font-size:16px"> 절차 지향 프로그래밍 </span>  
프로그램의 순서와 흐름을 먼저 세우고 필요한 자료구조와 함수들을 설계하는 방식  
어떤 기능을 어떤 순서로 처리할 것인가?

대표적인 절차 지향 프로그래밍 언어 : C, Visual Basic, Fortran, Pascal 등

#### 절차 지향 특징

- 하나의 큰 기능을 처리하기 위해 작은 단위의 기능들로 나누어 처리하는 Top-Down 접근 방식으로 설계
- 데이터를 중심으로 함수를 구현
- 프로그램이 커질수록 구조가 복잡해져 유지보수가 어려움 -> 소형 프로젝트에 적합

<span style="background-color:#fff5b1; font-size:16px"> 객체 지향 프로그래밍 </span>  
프로그램 구현에 필요한 객체를 파악하고 객체의 역할을 정의하여 객체 간의 상호작용을 통해 프로그램을 만드는 방식  
누가 어떤 일을 할 것인가?

대표적인 객체 지향 프로그래밍 언어 : C++, C#, Java, Python 등

#### 객체 지향 특징

- 세부 모델부터 설계하고 조립하는 Bottom-Up 접근 방식으로 설계
- 기능을 중심으로 메소드를 구현

---

## Restful API란?

<span style="font-size:16px"> REST 원리를 따르는 시스템 </span>

#### RESTful API 개발 원칙

- 자원을 식별할 수 있어야 함
- 행위는 명시적이어야 함
- 자기 서술적
- HATEOS (Hypermedia as the Engine of Application State)

#### +) REST API란?

Representational State Transfer의 약자로 소프트웨어 프로그램 아키텍처의 한 형식  
**자원을 이름으로 구분하여 해당 자원의 상태/정보를 주고받는 모든 것**을 의미

HTTP URI를 통해 자원을 명시, HTTP Method (POST, GET, PUT, DELETE) 를 통해 해당 자원에 대한 CRUD OPERATION을 적용하는 것  
=> 자원 기반의 구조로 설계의 중심에 Resoure가 있고 HTTP Method를 통해 Resource를 처리하도록 설계된 아키텍쳐

#### REST의 구성

- 자원 Resource - URL
- 행위 Verb - HTTP Method
- 표현 Representations

#### REST의 특징

- 클라이언트/서버 구조
  - 클라이언트는 유저와 관련된 처리를, 서버는 REST API를 제공함으로써 역할이 명확하게 구분
- 무상태성 (Stateless)
  - REST는 HTTP의 특성을 이용하기 때문에 무상태성을 가짐
  - 서버에서 어떤 작업을 하기 위해 상태정보를 기억할 필요가 없고 들어온 요청에 대해 처리만 해주면 됨
- 캐시 처리 가능 (Cacheable)
  - 대량의 요청을 효율적으로 처리하기 위해 캐시가 요구됨
  - 캐시 사용을 통해 응답시간이 빨라지고 REST server 트랜잭션이 발생하지 않기 때문에 전체 응답시간, 성능, 서버의 자원 이용률이 향상
- 자체 표현 구조 (Self Descriptiveness)
  - JSON을 이용한 메시지 포맷을 사용하여 직관적으로 이해할 수 있고 REST API 메시지만으로 그 요청이 어떤 행위인지 알 수 있음
- 계층화 (Layered System)
  - 클라이언트와 서버가 분리되어 있기 때문에 중간에 프록시 서버, 암호화 계층 등 중간 매체를 사용할 수 있음
- 유니폼 인터페이스 (Uniform)
  - URI로 지정한 리소스에 대한 조작을 가능하게 하는 아키텍쳐 스타일
  - UIR로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행 => 특정 언어나 기술에 종속되지 않음

#### REST API 규칙

1. 슬래시 구분자(/)는 계층 관계를 나타내는 데 사용
2. URI 마지막 문자로 슬래시(/)를 포함하지 않음
3. 언더바(\_) 대신 하이픈(-) 사용
4. URI 경로는 소문자를 사용
5. 파일확장자는 URI에 포함하지 않음
6. 전달하고자 하는 명사를 사용하되, 컨트롤 자원을 의미하는 경우만 예외적으로 동사 사용
7. URI에 작성되는 영어는 복수형으로 작성

---

## 프레임워크와 라이브러리의 차이

<span style="background-color:#fff5b1; font-size:16px"> 프레임워크 </span>  
개발자가 개발을 쉽게 할 수 있도록 뼈대를 제공해주는 것

ex. Java 개발에 사용되는 -> Spring  
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Python 개발에 사용되는 -> Django  
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;안드로이드 앱개발에 사용되는 -> Android

<span style="background-color:#fff5b1; font-size:16px"> 프레임워크 </span>  
개발에 필요한 것들을 미리 구현해놓은 도구  
재사용이 가능한 기능을 미리 구현해놓고 필요한 곳에서 호출하여 사용하도록 만들어진 집합

ex. Python의 pip로 설치한 패키지 / 모듈 ( andas, tensorflow 등)

<span style="color:red;"> 프레임워크는 라이브러리를 포함!!! </span>

프레임워크 위에 개발자가 작성한 애플리케이션 코드가 올라감  
이 코드에서 라이브러리 호출 가능

### 프레임워크와 라이브러리의 차이 => 제어 흐름에 대한 주도성이 누구에게 / 어디에 있는가

프레임워크 : 프레임워크가 제어 흐름의 주도성을 가짐 / 프레임워크가 제공하는 틀에 따라 코드를 작성해야 함
라이브러리 : 개발자가 제어 흐름의 주도성을 가짐 / 어떤 기능을 사용할지 개발자가 골라서 작성함

---

## 동기와 비동기의 차이

<span style="background-color:#fff5b1; font-size:16px"> 동기 (Synchronous) </span>  
요청과 결과가 동시에 일어난다는 약속  
요청을 하면 시간이 얼마나 걸리던 요청한 자리에서 결과가 주어져야 함  
순서에 맞춰 진행됨  
여러 개의 요청 동시 처리 불가

<span style="background-color:#fff5b1; font-size:16px"> 비동기 (Asynchronous) </span>  
요청과 결과가 동시에 일어나지 않을거라는 약속  
하나의 요청에 따른 응답을 즉시 처리하지 않아도 그 대기 시간동안 다른 요청에 대해 처리가 가능함  
여러 개의 요청 동시 처리 가능  
속도가 느림
