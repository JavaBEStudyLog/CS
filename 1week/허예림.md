## 1. 멀티 쓰레드와 멀티 프로세스의 차이점
#### 멀티 프로세스
- 멀티 프로세스는 각각 독립된 메모리 공간을 가진 여러 프로세스가 동시에 실행되는 방식입니다. 
- 장점 : 각각의 프로세스가 독립된 메모리 공간을 가지기 때문에 하나의 프로세스가 실패해도 다른 프로세스에 영향을 주지 않습니다.
- 단점 : 프로세스 간 통신 비용이 높고, 메모리 사용량이 많다는 단점을 가지고 있습니다. 각 프로세스가 독립된 메모리 공간을 가지기 때문에 같은 데이터를 여러 프로세스에 사용할 경우 중복 저장되어 메모리 사용량이 증가할 수 있습니다.
- 사용예 : 웹 서버와 데이터 베이스 서버를 별도의 프로세스로 실행하여, 하나의 서버에 문제가 발생해도 다른 서버는 정상적으로 동작할 수 있습니다.
#### 멀티 쓰레드 
- 멀티 쓰레드 : 멀티 스레드는 하나의 프로세스 내에서 여러 스레드가 메모리를 공유하며 동시에 실행되는 방식입니다.
- 장점 : 각각의 쓰레드는 하나의 프로세스 내에서 실행되기 때문에 스레드 간 데이터를 공유할 수 있습니다. 따라서 데이터 복사에 사용되는 비용과 통신 비용이 줄어든다는 장점이 있습니다.
- 단점 : 스레드간의 동기화 문제가 발생할 수 있습니다. 공유된 메모리에 여러 스레드가 동시에 접근할 경우, 데이터의 일관성을 유지하기 위한 추가적인 작업이 필요합니다.
- 사용예 : 웹 서버에서 동시에 여러 요청을 처리할 때 멀티 스레드를 사용하면, 각 요청을 별도의 스레드에서 처리하여 처리 속도를 높일 수 있습니다.
 
> 멀티 프로세스는 각각의 독립된 메모리 공간을 가진 여러 프로세스가 동시에 실행되는 방식으로 프로세스 간 통신 비용이 높지만 시스템 안전성을 유지할 수 있다는 특징을 가지고 있습니다.
멀티 쓰레드는 하나의 프로세스 내에서 여러 스레드가 메모리를 공유하여 실행되는 방식으로 스레드간 데이터 공유가 가능하며, 스레드 동기화 문제를 유의해야한다는 특징이 있습니다.

## 2. 프로세스와 스레드차이
#### 프로세스
- 프로세스는 실행중인 프로그램으로 디스크에 있던 프로그램을 메모리에 적재하여 운영체제의 제어를 받는 상태가 되면 프로세스가 실행중이라고 봅니다.
- 프로세스를 생성하거나 실행하기 위해서 프로세서 점유시간, 메모리, 파일, 입출력 장치 같은 자원을 운영체제로 부터 할당받게 됩니다. 또 현재의 활동 상태를 나타내는 프로그램 카운터, 프로세서의 현재 활동 내용도 포함하게 됩니다.
- 프로그램은 컴파일한 코드와 초기화 전역 변수, 문자열과 문자열 상수 등 정적 데이터를 포함하는 정적인 개체입니다. 이를 메모리에 적재하여 실행하게 되면 프로세스와 같이 현재 상태를 갖는 동적인 개체가 됩니다.
- 프로세스의 일반적인 메모리 구조로는 스택, 힙, 데이터, 코드 영역으로 이루어집니다.
- 사용예 : 웹 브라우저 한개당 한가지의 프로세스를 할당합니다. 웹 브라우저를 2개열면 2개의 프로세스를 생성합니다.
#### 스레드
- 스레드는 프로세스가 할당 받은 자원을 이용하는 실행 흐름의 단위입니다.
- 스레드는 프로세스의 직접 실행 정보를 제외한 나머지 프로세스 관련 정보를 공유합니다.
- 스레드는 프로그램 카운터(PC)와 스택 포인터 (SP)등을 비롯하여 스레드 실행 환경 정보, 지역 데이터, 스택을 독립적으로 가지면서 코드, 전역 데이터, 힙을 다른 스레드와 공유합니다.
- (사용자 응답성 증가) 스레드는 병렬 프로그래밍으로 계속 프로그램을 실행할 수 있어 사용자 응답성이 증가합니다.
- (프로세스의 자원과 메모리 공유 가능) : 스레드들이 프로세스 자원 하나와 메모리를 공유하므로 응용 프로그램 하나가 동일한 주소 공간에서도 스레드를 여러 개 실행하여 시스템 성능을 향상시킬 수 있습니다.
- (경제성이 좋음) : 스레드간에는 문맥 교환이 가능하기 때문에 프로세스를 생성하는 것보다 스레드를 생성하는 것이 비용 감소에 도움이 됩니다.
- (멀티 프로세싱) :각 스레드를 여러 프로세스에 병렬로 실행하여 성능과 효율을 높일 수 있습니다.
- 사용예 : 하나의 스레드가 웹 브라우저를 로딩하는 동안 다른 스레드에서는 사용자와 상호 작용 할 수 있습니다.

> 프로세스는 실행중인 프로그램을 의미합니다. 프로세스는 운영체제로부터 독립된 메모리 공간을 할당받아 실행되며 스택, 힙, 데이터, 코드 영역으로 이루어져 있습니다. 스레드는 프로세스가 할당 받은 자원을 이용하는 실행 흐름 단위로 프로세스 내의 메모리를 공유하며 실행됩니다.

## 3. 세그멘테이션와 페이징의 차이
#### 세그멘테이션(Segmentation)
- 프로세스를 논리적 내용을 기반으로 나누어 메모리에 배치하는 것을 의미합니다.
- 프로세스를 세그먼트의 집합으로 생각합니다.

#### 페이징(Paging)
- 논리주소의 메모리를 고정된 크기의 페이지로 나누어 관리하는 기법입니다.
- 페이지는 모두 같은 크기를 가지며 물리 주소 공간은 연속적이지 않을 수 있습니다.
> 페이징은 논리 주소의 메모리를 고정된 크기로 나누어 관리하는 메모리 기법이고, 세그멘테이션은 가변 크기로 나누어 메모리를 관리하는 기법입니다. 페이징은 비연속적으로 메모리에 할당될 수 있고, 세그멘테이션은 논리적인 구조에 따라 메모리에 할당 됩니다.

## 4. 데드락 설명과 해결방법
#### 교착상태(Deadlock)
- 교착상태는 여러 프로세스가 서로 자원을 기다리며 무한 대기하는 상황을 의미합니다.
- 발생조건1 상호배제 (Mutual Exclusion) :병행 프로세스에서 프로세스 하나가 공유 자원을 사용할 때 다른 프로세스들이 동일한 일을 할 수 없도록 하는 방법입니다. 
- 발생조건2 점유대기 (Hold and wait) : 자원을 점유한 상태에서 다른 자원을 추가로 기다리는 프로세스가 있어야 합니다.
- 발생조건3 비선점 (No Preemption) : 이미 할당된 자원을 강제로 빼앗을 수 없습니다.
- 발생조건4 환형 대기(Circular Wait): 두 개 이상의 프로세스가 원형으로 서로의 자원을 기다리는 상태가 존재해야 합니다.
- 교착 상태는 위의 네가지 조건이 동시에 충족되면 발생합니다.

#### 해결 방법
- 예방 (Prevention): 교착 상태는 4가지가 동시에 충족되어야 발생하기 때문에 발생 조건중 하나 이상을 제거하여 교착상태를 예방할 수 있습니다.
- 회피 (Avoidence) : 자원 할당 시 교착 상태가 발생하지 않는 안전항 상태를 유지합니다.
- 탐지 (Detection) : 교착 상태가 발생하는 것을 허용한 후 주기적으로 탐지 알고리즘을 활용해 확인합니다.
- 복구 (Recovery) : 교착 상태가 발생한 경우 복구를 시도합니다.
> 교착 상태는 여러 프로세스가 서로 자원을 기다리며 무한 대기하는 상황으로 상호 배제, 점유 대기, 비선점, 환형 대기 4가지 조건이 충족될 경우 발생합니다. 교착 상태를 해결하기 위해 4가지 조건 중 하나 이상을 제거하는 예방, 안전항 상태를 유지하는 회피, 주기적으로 탐색하는 탐지, 복구를 시도하는 복구를 활용할 수 있습니다. 

## 5. 선점형과 비선점형
#### 선점형 스케줄링 (Preemption)
- 어떤 프로세스가 CPU를 할당 받아 사용하고 있을 때 다른 프로세스가 CPU를 빼앗아 사용할 수 있는 방식입니다. 
- 장점 : 프로세스 우선순위가 높은 프로세스가 CPU를 먼저 차지하여 급히 실행해야하는 일이 많은 경우에 유용합니다.
- 단점 : 문맥 교환이 자주 발생하게 되어 오버헤드를 초래할 수 있습니다.
- 종류: SRT, 라운드 로빈, 멀티 레벨 큐등
  
#### 비선점형 스케줄링 (Non-Preemption)
- 어떤 프로세스가 CPU를 할당 받아 사용하면 그 프로세스가 종료되거나 입출력 요구가 발생하여 자발적으로 중지될 때까지 계속 실행을 보장하는 방식입니다.
- 장점 : 선점형 스케줄링에 비해 문맥교환이 적어 오버헤드 발생 위험이 적습니다.
- 단점 : CPU 사용시간이 짧은 프로세스들을 오랫동안 대기시킬 수 있어 처리율이 떨어 질 수 있습니다.
- 종류 : 선입 선출, SJF, 우선순위 스케줄링 등

> 선점형 스케줄링은 한 프로세스가 CPU를 점유하여 사용하고 있을 때 다른 프로세스가 CPU를 강탈하여 사용할 수 있도록 하는 방식입니다. 우선 순위가 높은 프로세스가 먼저 실행되어 작업 처리율이 좋지만, 잦은 문맥교환으로 오버헤드 발생 위험이 크다는 단점이 있습니다. 반대로 비선점형 스케줄링은 한 프로세스가 CPU를 점유하여 사용하고 있을 경우 자발적으로 중지될 때까지 실행을 보장하는 방식입니다. 선점형 스케줄링에 비해 작업 처리율은 떨어지지만 적은 문맥교환으로 오버헤드 발생 위험이 적습니다.
