## 멀티 쓰레드와 멀티 프로세스의 차이

<span style="background-color:#fff5b1; font-size:16px"> 멀티 프로세스 </span>

: 운영체제에서 **하나의 응용 프로그램에 대해 동시에 여러 개의 프로세스를 실행**할 수 있게 하는 기술

#### 장점

- **프로그램 안정성** : 한 프로세스가 비정상적으로 종료되도 다른 프로세스에 영향을 주지 않음  
  &nbsp;&nbsp;&nbsp;&nbsp; ex. 브라우저에 여러 개의 탭, 여러 곳의 웹사이트 방문 -> 어느 한 탭이 먹통이 되도 다른 탭들은 정상 작동
- **프로그램 병렬성** : 다중 CPU 시스템에서 각 프로세스를 병렬적으로 실행하여 성능을 향상시킴  
  &nbsp;&nbsp;&nbsp;&nbsp; ex. 이미지 처리나 비디오 인코딩같은 작업 -> 여러 개의 코어나 CPU에 분산시켜 빠르게 처리 가능
- **시스템 확장성** : 새로운 기능이나 모듈 추가 혹은 수정 시 다른 프로세스에 영향을 주지 않기 때문에 확장에 용이함  
  &nbsp;&nbsp;&nbsp;&nbsp; ex. 하나의 컴퓨터에 여러 개의 서버 프로세스 -> 요청 분산 처리

#### 단점

- **Context-Switching Overhead** : 프로세스의 상태 정보를 저장하고 복원하는 과정인 Context-Switching이 빈번하면 오버헤드가 발생할 수 있음
- **자원 공유 비효울성** : 멀티 프로세스는 각 프로세스가 독립적인 메모리 공간을 가지므로, 메모리 사용량이 증가하게 됨  
  &nbsp;&nbsp;&nbsp;&nbsp; +) 프로세스 간에 자원 공유가 필요한 경우 IPC를 사용해야 함 => 코드 복잡도 증가, IPC 자체 오버헤드 발생

<br>

<span style="background-color:#fff5b1; font-size:16px"> 멀티 스레드 </span>

: **하나의 프로세스 안에 여러 개의 스레드**가 존재하는 것으로 두 가지 이상의 동작을 동시에 처리할 수 있게 하는 기술

#### 장점

- **자원의 효울성** : 스레드는 stack 영역만 할당받고 나머지 영역은 공유하기 때문에 시스템 자원 소모가 줄어듬 (IPC 불필요)
- **Context-Switching 비용 감소** : 스레드에도 Context-Switching Overhead가 존재하긴 하지만, 프로세스에 비해 비용이 상대적으로 낮음

#### 단점

- **안정성 문제** : 하나의 스레드에 문제가 발생하면 다른 스레드들도 영향을 받아 전체 프로그램이 종료될 수 있음
- **동기화로 인한 성능 저하** : 여러 개의 스레드가 동시에 공유 자원에 접근할 수 있기 때문에, 동기화 문제가 발생  
  &nbsp;&nbsp;&nbsp;&nbsp; => 여러 스레드 접근을 제한하면서 병목 현상이 발생해 성능 저하 가능성이 높아짐

---

## 프로세스와 스레드의 차이

<span style="background-color:#fff5b1; font-size:16px"> 프로세스 </span>
: 운영체제로부터 자원을 할당받은 **작업의 단위**

#### 특징

- 각각 독립된 메모리 영역을 할당받음 (Code, Data, Stack, Heap)
- 최소 1개 이상의 스레드를 가짐
- 각 프로세스는 별도의 주소 공간에서 실행되며 기본적으로 다른 프로세스의 자원에 접근할 수 없음
- 한 프로세스가 다른 프로세스이 자원에 접근하려면 프로세스 간 통신(IPC)를 사용해야 함

<br>

<span style="background-color:#fff5b1; font-size:16px"> 스레드 </span>
: 프로세스가 할당받은 자원을 이용하는 실행 **흐름의 단위**

#### 특징

- 프로세스 내에서 필요한 Stack만 할당받고 Code, Data, Heap 영역은 공유함

> **_프로그램 -> 프로세스 -> 스레드_**  
> 프로그램 : 파일이 저장 장치에 저장되어 있지만 메모리에는 올라가있지 않은 정적인 상태 (ex. _.dmg, _.exe. => 코드 덩어리)  
> 프로세스 : 프로그램을 실행하여 해당 파일이 메모리에 올라가있는 동적인 상태 (실행되고 있는 컴퓨터 프로그램)  
> 스레드 : 프로그램이 복잡해지면서 하나의 프로그램이 다양한 작업을 하게 되면서 더 작은 실행 단위 개념으로 사용됨  
> &nbsp;&nbsp;&nbsp;&nbsp; == 프로세스의 코드에 정의된 절차에 따라 실행되는 특정한 수행 경로!

---

## 세그먼트와 페이징의 차이

<span style="font-size:16px"> 메모리 관리 기법 중 불연속 메모리 할당 기법에 해당하는 방식 </span>

<span style="background-color:#fff5b1; font-size:16px"> 페이징 </span>
: 프로세스를 페이지(page)라는 고정된 크기로 나누는 방식  
 내부 단편화 발생 가능성이 있음

<span style="background-color:#fff5b1; font-size:16px"> 세그먼트 </span>
: 프로세스를 세그멘트(segment)라는 가변 크기로 나누는 방식  
 외부 단편화 발생 가능성이 있음

#### + 메모리 관리 기법

1. 연속 메모리 관리

   - 고정 분할 기법 : 주기억장치가 고정된 파티션으로 분할 => **내부 단편화 발생**
   - 동적 분할 기법 : 파티션들이 동적 생성되며, 자신과 같은 크기의 파티션에 적재됨 => **외부 단편화 발생**

2. 불연속 메모리 관리
   - 페이징 : **고정 사이즈**의 작은 프로세스 조각
   - 프레임 : 페이지 크기와 같은 주기억장치 메모리 조각
   - 단편화 : 기억장치의 빈 공간 혹은 자료가 여러 조각으로 나뉘는 현상
   - 세그먼트 : **서로 다른 크기**를 가진 논리적 블록이 연속적 공간에 배치되는 것

---

## 데드락 개념과 해결 방법

<span style="font-size:16px"> DeadLock == 교착상태 </span>
: 두 개 이상의 프로세스나 스레드가 자원을 얻지 못해 다음 처리를 못하고 무한히 다음 자원을 기다리게 되는 상태를 말함  
 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생

#### + 데드락 발생 조건 (아래 4가지 모두 만족해야 함)

1. 상호 배제 : 자원은 한번에 한 프로세스만 사용이 가능
2. 점유 대기 : 최소한 하나의 자원을 점유하고 있으면서, 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재
3. 비선점 : 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음
4. 순환 대기 : 프로세스의 집합에서 순환 형태로 자원을 대기해야 함

#### 데드락 처리 방법

- 예방 / 회피
  - 예방 : 교착 상태 발생 조건 중 하나를 제거하여 해결 -> 자원 낭비가 심함
  - 회피 : 교착 상태 발생 시 피해나가는 방법으로 리소스 할당 측면에서 교착 상태가 발생할 가능성이 있는 자원을 할당하지 않음 -> 은행원 알고리즘
- 탐지 / 회복
  - 탐지 : 시스템에 교착 상태가 발생했는지 점검하여 교착 상태를 탐지 -> 교착 상태 발견 알고리즘, 자원 할당 그래프 등을 사용
  - 회복 : 교착 상태 일으킨 프로세스를 종료시키거나 할당된 자원을 해제시켜 회복

---

## 선점형과 비선점형

<span style="font-size:16px"> CPU를 사용하려고 하는 프로세스들 사이의 우선순위를 관리하는 작업의 종류</span>

<span style="background-color:#fff5b1; font-size:16px"> 선점형 스케줄링 </span>
: 어떤 프로세스가 CPU를 할당받아 실행중이더라도 운영체제가 강제로 CPU를 빼앗을 수 있는 스케줄링 방식  
=> 우선순위를 기준으로 일을 처리 => 응답 시간이 빠름

#### + 선점형 스케줄링의 종류

- **RR (Round Robin)** : 각 프로세스에 동일한 할당 시간을 부여  
  &nbsp;&nbsp;&nbsp;&nbsp; => 할당된 시간 내에 작업을 처리하지 못하면 준비 큐 리스트 맨 뒤로 보내지고, 다음 프로세스를 실행
- **SRF (Shortest Remaining-Time First)** : 현재 프로세스보다 더 빨리 끝낼 수 있는 프로세스가 들어오면 짧은 프로세스를 실행하도록 순서를 바꿈
- **다단계 큐** : 작업들을 각 목적에 맞게 여러 종류의 그룹으로 분할  
  &nbsp;&nbsp;&nbsp;&nbsp; => 큐의 우선순위에 맞게 프로세스 실행
- **다단계 피드백 큐** : 각 준비상태 큐마다 서로 다른 CPU 할당 시간을 부여한 뒤 시간 내에 처리하지 못한 프로세스는 다음 단계의 큐로 이동시킴  
  &nbsp;&nbsp;&nbsp;&nbsp; => 하위 단계로 내려갈수록 할당시간 증가

<span style="background-color:#fff5b1; font-size:16px"> 비선점형 스케줄링 </span>
: 프로세스가 자원을 할당받은 경우 반납할 때까지 계속 자원을 사용하도록 허용하는 스케줄링 방식  
=> 끝날 때까지 대기 => 응답 시간이 느림

#### + 비선점형 스케줄링의 종류

- **FCFS (First Come First Scheduling)** : 프로세스에 도착한 순서대로 CPU를 할당  
  &nbsp;&nbsp;&nbsp;&nbsp; => 수행 중인 긴 작업을 여러 개의 짧은 작업들이 기다리는 **호위효과** 발생
- **SJF (Shortest Job First)** : 대기하는 작업 중 수행 시간이 짧다고 판단되는 작업을 우선 수행하는 방식  
  &nbsp;&nbsp;&nbsp;&nbsp; => FCFS보다 평균 대기 시간 감소, 짧은 작업에 유리하지만 수행 시간이 긴 작업은 계속 뒤로 밀리는 문제 발생
- **HRN (Hightest Response-ration Next)** : SJF의 단점을 개선한 기법으로 각 작업의 우선순위를 계산하여 할당하는 방식  
  &nbsp;&nbsp;&nbsp;&nbsp; => **우선순위 = (대기시간 + 실행시간) / 실행시간**

- **Priority Scheduling (우선순위 스케줄링)** : 우선순위가 제일 높은 프로세스에게 CPU 할당 (같은 경우 FCFS 방식 적용)  
  &nbsp;&nbsp;&nbsp;&nbsp; => 우선순위가 높은 작업이 게속 들어오면 낮은 작업은 보장없이 머물게되는 **기아상태** 발생
